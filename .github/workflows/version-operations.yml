name: Version Operations

on:
  workflow_call:
    inputs:
      operation:
        description: "Operation to perform: 'validate' or 'update'"
        required: true
        type: string
      release_type:
        description: "Type of release (alpha, beta, RELEASE) - only for 'update'"
        required: false
        type: string
      should_bump_version:
        description: "Whether to bump the version number - only for 'update'"
        required: false
        type: boolean
        default: false
    secrets:
      APP_ID:
        required: false
      APP_PRIVATE_KEY:
        required: false
    outputs:
      current_version:
        description: "Current version before any changes"
        value: ${{ jobs.version-ops.outputs.current_version }}
      new_version:
        description: "New version after processing (only for 'update')"
        value: ${{ jobs.version-ops.outputs.new_version }}
      base_version:
        description: "Base version without suffixes"
        value: ${{ jobs.version-ops.outputs.base_version }}
      build_number:
        description: "Build number for non-RELEASE releases"
        value: ${{ jobs.version-ops.outputs.build_number }}
      short_sha:
        description: "Short commit SHA"
        value: ${{ jobs.version-ops.outputs.short_sha }}
      release_sha:
        description: "Release SHA for revert capability"
        value: ${{ jobs.version-ops.outputs.release_sha }}
      is_consistent:
        description: "Whether versions are consistent across packages"
        value: ${{ jobs.version-ops.outputs.is_consistent }}

jobs:
  version-ops:
    name: Version Operations
    runs-on: ubuntu-latest
    outputs:
      current_version: ${{ steps.check.outputs.current_version }}
      new_version: ${{ steps.update.outputs.new_version }}
      base_version: ${{ steps.check.outputs.base_version }}
      build_number: ${{ steps.update.outputs.build_number }}
      short_sha: ${{ steps.update.outputs.short_sha }}
      release_sha: ${{ steps.update.outputs.release_sha }}
      is_consistent: ${{ steps.check.outputs.is_consistent }}
    
    steps:
      - name: Generate token (for update operations only)
        id: generate_token
        if: inputs.operation == 'update'
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.generate_token.outputs.token || github.token }}

      - name: Setup Bun with version scripts
        uses: ./.github/actions/setup-bun-version
        with:
          checkout: 'false'  # Skip checkout since we already did it
          fetch-depth: 0
          token: ${{ steps.generate_token.outputs.token || github.token }}

      - name: Validate inputs
        run: |
          if [ "${{ inputs.operation }}" = "update" ]; then
            if [ -z "${{ inputs.release_type }}" ]; then
              echo "❌ release_type is required for 'update' operation"
              exit 1
            fi
          fi

      - name: Check version consistency
        id: check
        run: |
          echo "Checking version consistency across all package.json files..."
          
          # Get root version using our standard approach
          ROOT_VERSION=$(node -p "require('./package.json').version")
          echo "Root version: $ROOT_VERSION"
          echo "current_version=$ROOT_VERSION" >> $GITHUB_OUTPUT
          
          # Get base version using our script
          BASE_VERSION=$(bun run version:base)
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          
          # Use our centralized version script to check consistency
          if bun run version:check; then
            echo "is_consistent=true" >> $GITHUB_OUTPUT
            echo "✅ All versions are consistent!"
          else
            echo "is_consistent=false" >> $GITHUB_OUTPUT
            if [ "${{ inputs.operation }}" = "validate" ]; then
              echo "❌ Version inconsistency detected!"
              echo "Run 'bun run version:sync' to fix this."
              exit 1
            else
              echo "⚠️ Version inconsistency detected, will sync automatically"
              # Auto-sync versions if in update mode
              bun run version:sync
              echo "✅ Versions synchronized automatically"
            fi
          fi

      - name: Check if version should be bumped (alpha releases only)
        id: version_check
        if: inputs.operation == 'update' && inputs.release_type == 'alpha'
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token || github.token }}
        run: |
          # Get current version from current branch
          CURRENT_VERSION="${{ steps.check.outputs.current_version }}"
          CURRENT_BASE="${{ steps.check.outputs.base_version }}"

          # Get version from latest beta or production release (excluding alpha)
          LATEST_RELEASE_TAG=$(gh release list --limit 100 | cut -f3 | grep -E "(RELEASE)" | head -n1 || echo "")
          
          if [ -n "$LATEST_RELEASE_TAG" ]; then
            # Extract base version from latest beta/production release tag
            LATEST_RELEASE_BASE=$(echo "$LATEST_RELEASE_TAG" | sed 's/^v//' | sed 's/-.*$//')
            echo "Found latest beta/production release: $LATEST_RELEASE_TAG (base: $LATEST_RELEASE_BASE)"
          else
            # No beta/production releases found, use 0.0.0 as baseline
            LATEST_RELEASE_BASE="0.0.0"
            echo "No beta/production releases found, using baseline: $LATEST_RELEASE_BASE"
          fi

          echo "current_base=$CURRENT_BASE" >> $GITHUB_OUTPUT
          echo "latest_release_base=$LATEST_RELEASE_BASE" >> $GITHUB_OUTPUT

          # Check if current base is same or older than latest release (meaning we should bump)
          if [ "$CURRENT_BASE" = "$LATEST_RELEASE_BASE" ]; then
            echo "should_bump=true" >> $GITHUB_OUTPUT
            echo "✅ Current base matches latest release ($CURRENT_BASE = $LATEST_RELEASE_BASE) - will bump version"
          else
            # Use version comparison to check if current is newer
            if printf '%s\n%s\n' "$LATEST_RELEASE_BASE" "$CURRENT_BASE" | sort -V | head -n1 | grep -q "^$LATEST_RELEASE_BASE$"; then
              if [ "$CURRENT_BASE" != "$LATEST_RELEASE_BASE" ]; then
                echo "should_bump=false" >> $GITHUB_OUTPUT
                echo "⏭️  Current base is newer than latest release ($CURRENT_BASE > $LATEST_RELEASE_BASE) - will use current version"
              fi
            else
              echo "should_bump=true" >> $GITHUB_OUTPUT
              echo "✅ Current base is older than latest release ($CURRENT_BASE < $LATEST_RELEASE_BASE) - will bump version"
            fi
          fi

      - name: Update versions
        id: update
        if: inputs.operation == 'update'
        run: |
          BASE_VERSION="${{ steps.check.outputs.base_version }}"
          CURRENT_VERSION="${{ steps.check.outputs.current_version }}"
          
          # Use release_type directly as version suffix
          VERSION_SUFFIX="${{ inputs.release_type }}"
          
          # Extract existing build number and SHA from current version (if any)
          EXISTING_BUILD_NUMBER=""
          EXISTING_SHA=""
          # Handle both formats: suffix.buildnumber.sha and suffix.buildnumber
          if [[ "$CURRENT_VERSION" =~ -[a-zA-Z]+\.([0-9]+)\.([a-f0-9]+)$ ]]; then
            EXISTING_BUILD_NUMBER="${BASH_REMATCH[1]}"
            EXISTING_SHA="${BASH_REMATCH[2]}"
            echo "Found existing build number: $EXISTING_BUILD_NUMBER and SHA: $EXISTING_SHA"
          elif [[ "$CURRENT_VERSION" =~ -[a-zA-Z]+\.([0-9]+)$ ]]; then
            EXISTING_BUILD_NUMBER="${BASH_REMATCH[1]}"
            echo "Found existing build number: $EXISTING_BUILD_NUMBER (no SHA)"
          fi
          
          # Generate build info
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          
          # Build number logic:
          # - Alpha: Generate new build number and use current SHA
          # - Beta/RELEASE: Inherit build number and SHA from existing version
          case "${{ inputs.release_type }}" in
            "alpha")
              BUILD_NUMBER=$(date +%Y%m%d%H%M)
              # For alpha, use current commit SHA
              RELEASE_SHA="$SHORT_SHA"
              echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
              echo "release_sha=$RELEASE_SHA" >> $GITHUB_OUTPUT
              ;;
            "beta"|"RELEASE")
              if [ -n "$EXISTING_BUILD_NUMBER" ]; then
                BUILD_NUMBER="$EXISTING_BUILD_NUMBER"
                echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
                echo "Inheriting build number: $BUILD_NUMBER"
                
                # For beta/RELEASE, preserve the original alpha SHA for revert capability
                if [ -n "$EXISTING_SHA" ]; then
                  RELEASE_SHA="$EXISTING_SHA"
                  echo "release_sha=$RELEASE_SHA" >> $GITHUB_OUTPUT
                  echo "Inheriting release SHA: $RELEASE_SHA"
                else
                  echo "❌ No existing SHA found in version: $CURRENT_VERSION"
                  echo "Beta and RELEASE builds require an existing SHA from alpha for revert capability"
                  exit 1
                fi
              else
                echo "❌ No existing build number found in version: $CURRENT_VERSION"
                echo "Beta and RELEASE builds require an existing build number from alpha"
                exit 1
              fi
              ;;
          esac

          # Determine new version based on release type and bump requirements
          case "${{ inputs.release_type }}" in
            "alpha")
              if [ "${{ inputs.should_bump_version }}" = "true" ] && [ "${{ steps.version_check.outputs.should_bump }}" = "true" ]; then
                # Calculate new base version by bumping the latest release version
                LATEST_RELEASE_BASE="${{ steps.version_check.outputs.latest_release_base }}"
                
                # Use Node.js to properly increment the version
                NEW_BASE=$(node -e "
                  const latest = '$LATEST_RELEASE_BASE';
                  const [major, minor, patch] = latest.split('.').map(Number);
                  console.log(\`\${major}.\${minor}.\${patch + 1}\`);
                ")
                
                echo "Bumping from latest release base $LATEST_RELEASE_BASE to $NEW_BASE"
                
                # Set the new base version in all package.json files
                bun run version:set "$NEW_BASE"
                
                NEW_VERSION="${NEW_BASE}-${VERSION_SUFFIX}.${BUILD_NUMBER}.${RELEASE_SHA}"
              else
                NEW_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}.${BUILD_NUMBER}.${RELEASE_SHA}"
              fi
              ;;
            "beta")
              # For beta, keep the same base version but change suffix to beta
              # This preserves version progression: alpha -> beta -> RELEASE
              NEW_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}.${BUILD_NUMBER}.${RELEASE_SHA}"
              echo "Promoting from current version: $CURRENT_VERSION"
              echo "To beta version: $NEW_VERSION"
              ;;
            "RELEASE")
              NEW_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}.${BUILD_NUMBER}.${RELEASE_SHA}"
              ;;
            *)
              echo "❌ Unknown release type: ${{ inputs.release_type }}"
              exit 1
              ;;
          esac

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Final version: $NEW_VERSION"

          # Use our centralized version script to set the final version
          bun run version:set "$NEW_VERSION"
          
          # Verify versions are now consistent using our centralized script
          echo "Verifying version consistency:"
          bun run version:check

          # Update README version badge with simplified version
          if [ -f "README.md" ]; then
            # Simplify version for badge (strip build number and SHA)
            BADGE_VERSION="${BASE_VERSION}-${VERSION_SUFFIX}"

            # Update the version badge in readme using sed
            sed -i "s/\[\!\[Version\](https:\/\/img\.shields\.io\/badge\/v[^-]*-[^-]*-blue\.svg)\]/[![Version](https:\/\/img.shields.io\/badge\/v${BADGE_VERSION}-blue.svg)]/g" README.md
            echo "Updated README.md version badge to $BADGE_VERSION"
          fi

          # Commit the version changes (only for update operations)
          if [ "${{ inputs.operation }}" = "update" ]; then
            # Configure git
            git config --global user.name 'github-actions[bot]'
            git config --global user.email 'github-actions[bot]@users.noreply.github.com'

            # Add files to commit
            FILES_TO_ADD="package.json"
            for file in backend/package.json ui/package.json testing/alpha/package.json testing/beta/package.json testing/production/package.json README.md; do
              if [ -f "$file" ]; then
                FILES_TO_ADD="$FILES_TO_ADD $file"
              fi
            done

            git add $FILES_TO_ADD
            
            # Check if there are changes to commit
            if git diff --staged --quiet; then
              echo "No version changes to commit"
            else
              case "${{ inputs.release_type }}" in
                "alpha")
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION (alpha)"
                  ;;
                "beta")
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION (beta)"
                  ;;
                "RELEASE")
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION"
                  ;;
                *)
                  COMMIT_MSG="🔄 Update version to $NEW_VERSION"
                  ;;
              esac

              git commit -m "$COMMIT_MSG"
              git push origin HEAD
              echo "✅ Committed version changes: $NEW_VERSION"
            fi
          fi

      - name: Cleanup old releases
        if: inputs.operation == 'update'
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token || github.token }}
        run: |
          echo "🧹 Cleaning up old releases..."
          
          # Define retention policy
          case "${{ inputs.release_type }}" in
            "alpha")
              # Keep last 5 alpha releases
              KEEP_COUNT=5
              RELEASE_PATTERN="alpha"
              ;;
            "beta")
              # Keep last 3 beta releases
              KEEP_COUNT=3
              RELEASE_PATTERN="beta"
              ;;
            "RELEASE")
              # Keep all production releases (don't delete any)
              echo "Production releases are preserved - no cleanup needed"
              exit 0
              ;;
            *)
              echo "Unknown release type, skipping cleanup"
              exit 0
              ;;
          esac
          
          # Get releases matching the pattern, sorted by creation date (newest first)
          echo "Looking for $RELEASE_PATTERN releases to clean up..."
          
          # Get all releases and extract just the tag names (first column)
          ALL_RELEASES=$(gh release list --limit 100 | cut -f3)
          
          # Filter for releases matching our pattern and get tags to delete
          RELEASES_TO_DELETE=$(echo "$ALL_RELEASES" | grep "$RELEASE_PATTERN" | tail -n +$((KEEP_COUNT + 1)))
          
          if [ -z "$RELEASES_TO_DELETE" ]; then
            echo "No old $RELEASE_PATTERN releases found to delete"
          else
            echo "Found release tags to delete:"
            echo "$RELEASES_TO_DELETE"
            
            # Delete each old release
            echo "$RELEASES_TO_DELETE" | while read -r release_tag; do
              if [ -n "$release_tag" ]; then
                echo "Deleting release: $release_tag"
                gh release delete "$release_tag" --yes || echo "Failed to delete release $release_tag"
                
                # Also delete the git tag
                echo "Deleting tag: $release_tag"
                git push origin --delete "$release_tag" || echo "Failed to delete tag $release_tag"
              fi
            done
            
            echo "✅ Cleanup completed"
          fi
