name: Beta Release

on:
  push:
    branches: [test]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: read

jobs:
  beta-release:
    name: Create Beta Release (test)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          
      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
          
      - name: Configure git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
      - name: Determine version for beta
        id: version
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          # Remove any existing suffix to get the base version
          BASE_VERSION=$(echo "$CURRENT_VERSION" | sed 's/-alpha.*//g' | sed 's/-beta.*//g')
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          # Generate build number based on timestamp and commit hash
          BUILD_NUMBER=$(date +%Y%m%d%H%M%S)
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          
          # For beta, DO NOT increment version - just add beta suffix with build number
          NEW_VERSION="$BASE_VERSION-beta.$BUILD_NUMBER+$SHORT_SHA"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Beta version will be: $NEW_VERSION (no version increment)"
          
      - name: Update versions (beta build)
        run: |
          # Set the new version in all packages
          node scripts/version.js set ${{ steps.version.outputs.new_version }}
          # Sync to ensure all packages are consistent
          npm run version:sync
          # Verify versions are now consistent
          echo "Verifying version consistency:"
          for file in package.json backend/package.json ui/package.json test/package.json; do
            if [ -f "$file" ]; then
              VERSION=$(node -p "require('./$file').version")
              echo "$file: $VERSION"
            fi
          done
          
      - name: Update README version badge
        run: |
          # Update version badge in README.md
          sed -i "s/version-[0-9]\+\.[0-9]\+\.[0-9]\+\(-[a-zA-Z0-9\.-]*\)\?-blue/version-${{ steps.version.outputs.new_version }}-blue/g" README.md
          echo "Updated README.md version badge to ${{ steps.version.outputs.new_version }}"
          
      - name: Build and test
        run: |
          # Build backend
          echo "Building backend..."
          cd backend
          bun install
          bun run build
          cd ..
          
          # Build UI
          echo "Building UI..."
          cd ui
          bun install
          bun run build
          cd ..
          
          # Run tests
          echo "Running tests..."
          cd test
          bun install
          bun run test || echo "Tests failed, but continuing with release"
          cd ..
          
      - name: Commit version updates
        run: |
          git add package.json backend/package.json ui/package.json test/package.json README.md
          git commit -m "chore: beta build ${{ steps.version.outputs.new_version }} [skip ci]"
          git push origin test
          
      - name: Create and push tag
        run: |
          git tag "v${{ steps.version.outputs.new_version }}"
          git push origin "v${{ steps.version.outputs.new_version }}"
          
      - name: Get commit SHAs for this PR
        id: pr_commits
        run: |
          # Find the PR that was merged to trigger this push
          echo "Looking for PR associated with this push..."
          
          # Try to find PR number from the push event or recent merge commit
          PR_NUM=""
          
          # Method 1: Check if this push was from a merged PR by looking at recent commits
          RECENT_COMMIT_MSG=$(git log --format="%s" -n 1)
          if echo "$RECENT_COMMIT_MSG" | grep -E "Merge pull request #[0-9]+" > /dev/null; then
            PR_NUM=$(echo "$RECENT_COMMIT_MSG" | grep -oE "#[0-9]+" | sed 's/#//')
            echo "Found PR number from merge commit: $PR_NUM"
          fi
          
          # Method 2: Use GitHub API to find PRs that were merged recently
          if [ -z "$PR_NUM" ]; then
            echo "Searching for recently merged PRs..."
            PR_NUM=$(gh api repos/${{ github.repository }}/pulls \
              --field state=closed \
              --field base=test \
              --field sort=updated \
              --field direction=desc \
              --jq '.[] | select(.merged_at != null) | select(.merge_commit_sha == "'${{ github.sha }}'") | .number' \
              | head -n1)
          fi
          
          if [ -n "$PR_NUM" ]; then
            echo "Found PR #$PR_NUM"
            # Get the exact commits that were in this PR
            COMMITS=$(gh pr view "$PR_NUM" --repo "${{ github.repository }}" \
              --json commits --jq '.commits[].oid' | tr '\n' ' ')
            echo "commits=$COMMITS" >> $GITHUB_OUTPUT
            echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
            echo "Found ${#COMMITS[@]} commits in PR #$PR_NUM"
          else
            echo "No PR found for this push"
            echo "commits=" >> $GITHUB_OUTPUT
            echo "pr_number=" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        id: changelog
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "Generating beta changelog with AI summaries..."
          
          # Get commits from the specific PR
          ALL_SHAS="${{ steps.pr_commits.outputs.commits }}"
          PR_NUM="${{ steps.pr_commits.outputs.pr_number }}"
          
          if [ -z "$ALL_SHAS" ]; then
            echo "âš ï¸  No PR commits foundâ€”using fallback to recent commits"
            # Fallback to recent commits if no PR detected
            ALL_SHAS=$(git log --pretty=format:"%H" --no-merges --reverse -10 | tr '\n' ' ')
          else
            echo "Using commits from PR #$PR_NUM: $ALL_SHAS"
          fi
          
          # Function to get AI summary of commit comments
          get_ai_summary() {
            local commits="$1"
            local all_comments=""
            
            for sha in $commits; do
              if [ -n "$sha" ]; then
                # Get AI comment for this commit
                ai_comment=$(gh api repos/${{ github.repository }}/commits/$sha/comments --jq '.[0].body // ""' 2>/dev/null || echo "")
                commit_msg=$(git log --format="%s" -n 1 $sha)
                
                if [ -n "$ai_comment" ]; then
                  all_comments="${all_comments}**${commit_msg}**: ${ai_comment}\n\n"
                else
                  echo "No AI comment found for commit $sha: $commit_msg"
                fi
              fi
            done
            
            if [ -n "$all_comments" ]; then
              # Use OpenAI to summarize the commit comments into concise changelog entries
              summary=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d '{
                  "model": "gpt-4o-mini",
                  "messages": [
                    {
                      "role": "system",
                      "content": "You are a technical writer creating concise changelog entries. Summarize the provided commit comments into bullet points that highlight the key changes, features, fixes, and improvements. Each bullet should be clear, concise (1-2 lines max), and focus on user-facing changes. Use action verbs and be specific about what changed."
                    },
                    {
                      "role": "user", 
                      "content": "Summarize these commit comments into concise changelog entries:\n\n'"$all_comments"'"
                    }
                  ],
                  "max_tokens": 500,
                  "temperature": 0.3
                }' | jq -r '.choices[0].message.content // "- No changes summarized"')
              
              echo "$summary"
            else
              echo "- No AI comments found for any commits"
            fi
          }
          
          # Generate AI-powered changelog
          CHANGELOG=$(get_ai_summary "$ALL_SHAS")
          
          # Save changelog for release notes
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "### Changes in v${{ steps.version.outputs.new_version }} (Beta)" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Create GitHub Beta Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          tag: v${{ steps.version.outputs.new_version }}
        run: |
          # Create release notes content
          cat > release_notes.md << 'EOF'
          # SMART on FHIR Proxy v${{ steps.version.outputs.new_version }} (Beta)
          
          ðŸ§ª **This is a beta release** - Suitable for testing and staging environments.
          
          **Build Info:**
          - Build Number: ${{ steps.version.outputs.build_number }}
          - Commit: ${{ steps.version.outputs.short_sha }}
          - Built from: `test` branch
          
          ${{ steps.changelog.outputs.changelog }}
          
          ## Components
          - **Backend**: SMART on FHIR Proxy Server
          - **UI**: Administration Interface  
          - **Test Suite**: Comprehensive FHIR compliance tests
          
          ## Installation
          ```bash
          git clone https://github.com/${{ github.repository }}.git
          cd smart-on-fhir-proxy
          git checkout v${{ steps.version.outputs.new_version }}
          ```
          
          See the [README](README.md) for setup instructions.
          EOF
          
          # Create prerelease with GitHub CLI
          gh release create "$tag" \
              --repo="$GITHUB_REPOSITORY" \
              --title="SMART on FHIR Proxy $tag (Beta)" \
              --notes-file release_notes.md \
              --prerelease \
              --generate-notes
