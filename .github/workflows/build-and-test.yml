name: Build

on:
  workflow_call:
    inputs:
      run_tests:
        description: "Whether to run tests"
        required: false
        type: boolean
        default: true
      fail_on_test_failure:
        description: "Whether to fail the workflow if tests fail"
        required: false
        type: boolean
        default: false
    secrets:
      APP_ID:
        required: false
      APP_PRIVATE_KEY:
        required: false
      OPENAI_API_KEY:
        required: false

jobs:
  build:
    name: Build Project
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun with version scripts
        uses: ./.github/actions/setup-bun-version
        with:
          checkout: 'false'  # Skip checkout since we already did it

      - name: Combined Build & Log
        id: build
        run: |
          set -o pipefail
          (
            echo "=== Building backend ==="
            cd backend && bun install && bun run build && cd ..
            echo "=== Building UI ==="
            cd ui && bun install && bun run build && cd ..
          ) 2>&1 | tee build.log

      - name: Authenticate as GitHub App
        if: failure()
        id: app-auth
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Auto-fix and retry build (up to 3 attempts)
        if: failure() && steps.app-auth.outputs.token
        id: auto-fix-retry
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ steps.app-auth.outputs.token }}
        run: |
          # Install curl for API calls
          curl --version || (apt-get update && apt-get install -y curl)
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          BUILD_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$BUILD_SUCCESS" = "false" ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "üîÑ Auto-fix attempt $RETRY_COUNT of $MAX_RETRIES"
            
            # Get the latest build log (either from initial build or previous retry)
            if [ $RETRY_COUNT -eq 1 ]; then
              LOG_FILE="build.log"
            else
              LOG_FILE="retry-build-$((RETRY_COUNT - 1)).log"
            fi
            
            # Ask GPT-4o for structured code fixes via API
            echo "üìù Analyzing build errors with AI (Structured Outputs)..."
            BUILD_ERRORS=$(sed -n '1,2000p' "$LOG_FILE" | sed 's/"/\\"/g' | tr '\n' '\\n')
            
            curl -s -X POST "https://api.openai.com/v1/chat/completions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "{
                \"model\": \"gpt-4o-2024-08-06\",
                \"messages\": [
                  {
                    \"role\": \"system\",
                    \"content\": \"You are a code fixing assistant. Analyze build errors and provide structured fixes.\"
                  },
                  {
                    \"role\": \"user\",
                    \"content\": \"Fix these build errors:\\n\\n$BUILD_ERRORS\"
                  }
                ],
                \"temperature\": 0.1,
                \"response_format\": {
                  \"type\": \"json_schema\",
                  \"json_schema\": {
                    \"name\": \"code_fixes\",
                    \"strict\": true,
                    \"schema\": {
                      \"type\": \"object\",
                      \"properties\": {
                        \"fixes\": {
                          \"type\": \"array\",
                          \"items\": {
                            \"type\": \"object\",
                            \"properties\": {
                              \"file_path\": {
                                \"type\": \"string\",
                                \"description\": \"Path to the file to fix\"
                              },
                              \"line_number\": {
                                \"type\": \"number\",
                                \"description\": \"Line number where the fix should be applied\"
                              },
                              \"search_text\": {
                                \"type\": \"string\",
                                \"description\": \"Exact text to search for and replace\"
                              },
                              \"replacement_text\": {
                                \"type\": \"string\",
                                \"description\": \"Text to replace the search text with\"
                              },
                              \"description\": {
                                \"type\": \"string\",
                                \"description\": \"Description of what this fix does\"
                              }
                            },
                            \"required\": [\"file_path\", \"search_text\", \"replacement_text\", \"description\"],
                            \"additionalProperties\": false
                          }
                        }
                      },
                      \"required\": [\"fixes\"],
                      \"additionalProperties\": false
                    }
                  }
                }
              }" | jq -r '.choices[0].message.content' > fix-$RETRY_COUNT.json

            # Debug: show what the AI generated
            echo "üîç AI generated structured fixes:"
            cat fix-$RETRY_COUNT.json
            echo "--- End of fixes ---"

            # Apply structured fixes
            PATCH_SUCCESS=false
            if [ -s fix-$RETRY_COUNT.json ] && jq -e '.fixes' fix-$RETRY_COUNT.json > /dev/null 2>&1; then
              echo "‚úÖ Valid structured fixes received"
              
              # Apply each fix
              jq -r '.fixes[] | @json' fix-$RETRY_COUNT.json | while read fix_json; do
                file_path=$(echo "$fix_json" | jq -r '.file_path')
                search_text=$(echo "$fix_json" | jq -r '.search_text')
                replacement_text=$(echo "$fix_json" | jq -r '.replacement_text')
                description=$(echo "$fix_json" | jq -r '.description')
                
                echo "üîß Applying fix: $description"
                echo "üìÅ File: $file_path"
                echo "üîç Search: $search_text"
                echo "üîÑ Replace: $replacement_text"
                
                if [ -f "$file_path" ]; then
                  # Use sed to replace the exact text
                  if sed -i "s|${search_text}|${replacement_text}|g" "$file_path" 2>/dev/null; then
                    echo "‚úÖ Fix applied successfully"
                    PATCH_SUCCESS=true
                  else
                    echo "‚ùå Failed to apply fix"
                  fi
                else
                  echo "‚ùå File not found: $file_path"
                fi
              done
            else
              echo "‚ö†Ô∏è Invalid or empty fixes JSON - no fallback available"
            fi

            # Only commit & push if patch was applied successfully AND there are actual code changes
            if [ "$PATCH_SUCCESS" = "true" ]; then
              # Remove build artifacts and patch files from staging
              git reset build.log fix-*.patch retry-build-*.log codex-prompt.txt 2>/dev/null || true
              rm -f build.log fix-*.patch retry-build-*.log codex-prompt.txt 2>/dev/null || true
              
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              
              # Check if there are actual code changes (excluding build artifacts)
              if [ -n "$(git status --porcelain | grep -v build.log | grep -v fix-.*\.patch | grep -v retry-build-.*\.log | grep -v codex-prompt.txt)" ]; then
                git add .
                git commit -m "chore: auto-fix build errors (attempt $RETRY_COUNT/$MAX_RETRIES) via OpenAI [skip ci]"
                git push
                echo "‚úÖ Code fixes applied and pushed (attempt $RETRY_COUNT)"
              else
                echo "‚ö†Ô∏è No actual code changes to commit"
              fi
            else
              echo "‚ö†Ô∏è Skipping commit - patch failed to apply"
            fi
            
            # Retry the build
            echo "üîÑ Retrying build (attempt $RETRY_COUNT)..."
            set +e  # Don't exit on error
            (
              echo "=== Retrying Backend Build (attempt $RETRY_COUNT) ==="
              cd backend && bun install && bun run build && cd ..
              echo "=== Retrying UI Build (attempt $RETRY_COUNT) ==="
              cd ui && bun install && bun run build && cd ..
            ) 2>&1 | tee retry-build-$RETRY_COUNT.log
            
            BUILD_EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            if [ $BUILD_EXIT_CODE -eq 0 ]; then
              BUILD_SUCCESS=true
              echo "‚úÖ Build succeeded on attempt $RETRY_COUNT!"
              echo "build_success=true" >> $GITHUB_OUTPUT
              echo "attempts_used=$RETRY_COUNT" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ùå Build failed on attempt $RETRY_COUNT"
              if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                echo "üí• All $MAX_RETRIES attempts failed. Giving up."
                echo "build_success=false" >> $GITHUB_OUTPUT
                echo "attempts_used=$RETRY_COUNT" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          done

      - name: Upload build artifacts
        if: (success() || steps.auto-fix-retry.outputs.build_success == 'true') && !startsWith(github.ref, 'refs/heads/dev/')
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            backend/dist/
            ui/dist/
          retention-days: 1

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build
    if: ${{ inputs.run_tests }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun with version scripts
        uses: ./.github/actions/setup-bun-version
        with:
          checkout: 'false'  # Skip checkout since we already did it

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Install dependencies
        run: |
          echo "Installing dependencies for testing..."
          cd backend && bun install && cd ..
          cd ui && bun install && cd ..

      - name: Test UI
        continue-on-error: ${{ !inputs.fail_on_test_failure }}
        timeout-minutes: 5
        env:
          CI: true
        run: |
          echo "Running UI tests (quick mode for CI)..."
          cd ui
          # Skip Playwright tests in CI for now since they're too slow
          echo "‚úÖ UI tests completed (skipped), TODO later"
          cd ..

      - name: Test backend
        continue-on-error: ${{ !inputs.fail_on_test_failure }}
        run: |
          echo "Running backend tests..."
          cd backend
          echo "‚è≠Ô∏è Skipping backend tests in CI for now, TODO later"
          cd ..
