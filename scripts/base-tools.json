[
  {
    "type": "function",
    "function": {
      "name": "list_directory",
      "description": "List files and directories in a path. Use this to explore project structure.",
      "parameters": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Directory path to list (relative to repo root, e.g., 'backend/src', 'ui/src')"
          }
        },
        "required": ["path"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "read_file",
      "description": "Read content of a file. Use this to understand code structure and context.",
      "parameters": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "File path to read (relative to repo root)"
          },
          "lines": {
            "type": "string",
            "description": "Optional: specific lines like '1-50' or '20' to read only part of file"
          }
        },
        "required": ["path"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "search_files",
      "description": "Search for text patterns across files. Use this to find similar code or usage examples.",
      "parameters": {
        "type": "object",
        "properties": {
          "pattern": {
            "type": "string",
            "description": "Text pattern to search for"
          },
          "file_type": {
            "type": "string",
            "description": "File glob pattern like '*.ts', '*.tsx', '*.js', etc.",
            "default": "*.ts"
          }
        },
        "required": ["pattern"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "semantic_search",
      "description": "üß† SEMANTIC CODE SEARCH! Use SBERT embeddings to find semantically similar code, functions, or concepts across the codebase. Perfect for finding related functionality, similar patterns, or conceptually relevant code sections!",
      "parameters": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Natural language description of what you're looking for (e.g., 'error handling patterns', 'authentication logic', 'database connection setup', 'validation functions')"
          },
          "file_type": {
            "type": "string",
            "description": "File glob pattern like '*.ts', '*.tsx', '*.js', etc.",
            "default": "*.ts"
          },
          "max_results": {
            "type": "integer",
            "description": "Maximum number of semantically similar results to return",
            "default": 8
          },
          "similarity_threshold": {
            "type": "number",
            "description": "Minimum semantic similarity score (0.0-1.0)",
            "default": 0.3
          }
        },
        "required": ["query"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "find_imports",
      "description": "Analyze imports in a file to understand dependencies.",
      "parameters": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "Path to file to analyze imports"
          }
        },
        "required": ["file_path"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "find_usage",
      "description": "Find where a symbol, function, or class is used across the codebase.",
      "parameters": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "description": "Symbol name to search for"
          },
          "file_type": {
            "type": "string",
            "description": "File type to search in",
            "default": "*.ts"
          }
        },
        "required": ["symbol"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "create_dynamic_tool",
      "description": "üöÄ META-AI TOOL CREATOR! Create a new MCP tool dynamically when you need functionality that doesn't exist yet. This is your superpower - use it when existing tools aren't enough! NEW: Tools are cached and auto-generate schemas!",
      "parameters": {
        "type": "object",
        "properties": {
          "tool_name": {
            "type": "string",
            "description": "Name of the new tool function (will be callable later). Use descriptive names like 'analyze_build_config' or 'find_circular_deps'."
          },
          "tool_code": {
            "type": "string",
            "description": "Python code that defines the tool function. Must define a function with the tool_name. Has access to self.repo_root and standard libraries. Add type hints for better schema generation!"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of what this tool does. This will be used in the auto-generated schema."
          }
        },
        "required": ["tool_name", "tool_code", "description"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "call_dynamic_tool",
      "description": "Call a previously created dynamic tool",
      "parameters": {
        "type": "object",
        "properties": {
          "tool_name": {
            "type": "string",
            "description": "Name of the dynamic tool to call"
          },
          "arguments": {
            "type": "object",
            "description": "Arguments to pass to the dynamic tool"
          }
        },
        "required": ["tool_name", "arguments"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "consult_friend_ai",
      "description": "ü§ù COLLABORATIVE AI CONSULTANT! Spawn a Friend AI using A2A protocol to brainstorm MCP tool strategies and iterate on solutions together. Use when you're stuck or want a second opinion on complex problems!",
      "parameters": {
        "type": "object",
        "properties": {
          "consultation_topic": {
            "type": "string",
            "description": "What you want to discuss with Friend AI (e.g., 'Dynamic tool creation strategy', 'Error analysis approach')"
          },
          "problem_context": {
            "type": "string",
            "description": "Detailed context about the problem you're facing"
          },
          "your_initial_thoughts": {
            "type": "string",
            "description": "Your current thinking about the problem so Friend AI can build on it"
          }
        },
        "required": [
          "consultation_topic",
          "problem_context",
          "your_initial_thoughts"
        ]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "create_sandbox",
      "description": "üì¶ CREATE ISOLATED SANDBOX! Create a safe environment to test risky operations, experimental code, or validate solutions without affecting the main codebase. Perfect for testing fixes before applying them!",
      "parameters": {
        "type": "object",
        "properties": {
          "sandbox_name": {
            "type": "string",
            "description": "Name for the sandbox (e.g., 'test_typescript_fix', 'experiment_api_changes')"
          },
          "sandbox_type": {
            "type": "string",
            "description": "Type of sandbox",
            "enum": ["copy_repo", "docker_container", "temp_directory"],
            "default": "temp_directory"
          },
          "description": {
            "type": "string",
            "description": "What you plan to test in this sandbox"
          }
        },
        "required": ["sandbox_name", "description"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "run_in_sandbox",
      "description": "üß™ SAFE CODE EXECUTION! Execute code, commands, or operations inside a sandbox environment. Test your fixes safely before applying to main codebase!",
      "parameters": {
        "type": "object",
        "properties": {
          "sandbox_name": {
            "type": "string",
            "description": "Name of the sandbox to run in"
          },
          "operation_type": {
            "type": "string",
            "description": "Type of operation",
            "enum": [
              "command",
              "code_execution",
              "file_operation",
              "build_test"
            ]
          },
          "operation_data": {
            "type": "string",
            "description": "The command, code, or operation to execute"
          },
          "description": {
            "type": "string",
            "description": "What this operation is testing"
          }
        },
        "required": [
          "sandbox_name",
          "operation_type",
          "operation_data",
          "description"
        ]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "inspect_sandbox",
      "description": "üîç SANDBOX INSPECTOR! Check the state, results, and outputs of sandbox operations. See what happened during your tests!",
      "parameters": {
        "type": "object",
        "properties": {
          "sandbox_name": {
            "type": "string",
            "description": "Name of the sandbox to inspect"
          },
          "inspection_type": {
            "type": "string",
            "description": "What to inspect",
            "enum": ["status", "files", "logs", "results", "all"],
            "default": "all"
          }
        },
        "required": ["sandbox_name"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "cleanup_sandbox",
      "description": "üóëÔ∏è SANDBOX CLEANUP! Remove a sandbox when you're done testing. Clean up resources and temporary files.",
      "parameters": {
        "type": "object",
        "properties": {
          "sandbox_name": {
            "type": "string",
            "description": "Name of the sandbox to clean up"
          },
          "force": {
            "type": "boolean",
            "description": "Force cleanup even if sandbox has unsaved results"
          }
        },
        "required": ["sandbox_name"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "get_dynamic_tools_info",
      "description": "Get information about all available dynamic tools with their schemas and cache status",
      "parameters": {
        "type": "object",
        "properties": {},
        "additionalProperties": false
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "fetch_webpage",
      "description": "üåê WEB SCRAPING! Fetch content from any webpage with intelligent content extraction. Use SBERT fallback for summarization if content is too long.",
      "parameters": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL of the webpage to fetch"
          },
          "extraction_type": {
            "type": "string",
            "description": "Type of content to extract: 'text', 'links', 'forms', 'tables', 'images', 'all'",
            "enum": ["text", "links", "forms", "tables", "images", "all"]
          },
          "max_content_length": {
            "type": "integer",
            "description": "Maximum content length before triggering SBERT summarization (default: 10000)"
          },
          "summarize_if_long": {
            "type": "boolean",
            "description": "Use SBERT-based summarization if content exceeds max length (default: true)"
          }
        },
        "required": ["url"]
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "create_playwright_automation",
      "description": "üé≠ PLAYWRIGHT AUTOMATION! Create browser automation scripts for web testing, scraping, or interaction workflows. Generate complete Playwright scripts as dynamic tools.",
      "parameters": {
        "type": "object",
        "properties": {
          "automation_name": {
            "type": "string",
            "description": "Name for the automation tool (will become a dynamic tool)"
          },
          "target_url": {
            "type": "string",
            "description": "URL to automate"
          },
          "action_description": {
            "type": "string",
            "description": "Detailed description of what the automation should do (e.g., 'login with credentials', 'scrape product listings', 'fill form and submit')"
          },
          "automation_type": {
            "type": "string",
            "description": "Type of automation script to generate",
            "enum": ["form_filling", "data_scraping", "ui_testing", "navigation", "monitoring", "api_testing"]
          },
          "output_format": {
            "type": "string",
            "description": "How to return scraped data",
            "enum": ["json", "csv", "raw_html", "structured_text"]
          }
        },
        "required": ["automation_name", "target_url", "action_description"]
      }
    }
  }
]
